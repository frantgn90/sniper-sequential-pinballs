#!/usr/bin/env python

import sys, getopt
import argparse
#from __future__ import print_function

def readPoints(pointsfile):
	"""
	Reads the simpoints from points file and return them in a list
	
	@type	pointsfile: string
	@param	pointsfile: name of the points file (simpoint generated)
	@rtype	points: list
	@return	points: points generated by simpoint
	"""
	#print 'Points file is: ', pointsfile
	with open(pointsfile) as f:
		points = []
		for line in f:
			points.append(int(line.split()[0]))
			
	#print len(points)
	return points

def readLabels(labelsfile):
	"""
	Reads the simpoint generate labels file and return the labels in a list
	
	@type	pointsfile: string
	@param	pointsfile: name of the labels file (simpoint generated)
	@rtype	points: list
	@return	points: labels generated by simpoint
	"""
	print 'Reading labels from "' + labelsfile + '"...'
	with open(labelsfile) as f:
		labels = []
		for line in f:
			labels.append(int(line.split()[0]))
			
	print ' Read', len(labels), 'labels.'
	return labels

def readTrace(tracefile, col):
	"""
	reads the col'th element of trace pairs from trace file
	
	@type	tracefile: string
	@param	tracefile: name of the trace file (matching program generated)
	@rtype	traceSlices: list
	@return	traceSlices: instruction size slices generated by matching program
	"""
	with open(tracefile) as f:
		traceSlices = []
		for line in f:
                        vals = line.split(',')
                        try:
                                traceSlices.append(int(vals[col]))
                        except:
                                return []
				
	print 'Read', len(traceSlices), 'counts from column', col, 'of "' + tracefile + '; sum=', sum(traceSlices)
	return traceSlices

def measureWeightsWithLabels(labels, traceSlices):
	"""
	measures the weights for the trace
	
	@type	labels: list
	@param	labels: labels generated by simpoint
	@type	traceSlices: list
	@param	traceSlices: instruction size slices generated by matching program
	@rtype	weights: list
	@return	weights: weights for the selected labels of the trace
	"""
	
	weights = [0] * (max(labels)+1)
	if len(labels) != len(traceSlices):
		print 'Error: length of labels file does not equal that of matching instr-count file'
		sys.exit(1)
        grandSum = sum(traceSlices)
        for traceIdx, clusterIdx in enumerate(labels):
                weights[clusterIdx] += traceSlices[traceIdx]

        # normalize
        weights = [(float(x) / float(grandSum)) for x in weights]

        # adjust for any rounding error
        weights[max(labels)] += 1.0 - sum(weights)
	
	#print weights
	return weights

def writeMeasuredWeight(weights, outputWeightFile):
	"""
	writes the output weights in file
	
	@type	weights: string
	@param	weights: name of the trace file (matching program generated)
	@type	outputWeightFile: string
	@param	outputWeightFile: name of the output weight file
	"""
	print 'Writing weights to "', outputWeightFile, '"...'
	with open(outputWeightFile, 'w') as f:
		for idx, val in enumerate(weights):
                        if (val > 0): 
                                f.write(str(val) + ' ' + str(idx) + '\n')

def main(argv):
	"""
	main function parses the arguments and calls functions to do the job
	"""
        parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)
        parser.add_argument('--label-file', '-l', help='label file from simpoint tool', default='labels.txt')
        parser.add_argument('--match_file', '-m', help='matching instr-count file from the crossBinMatcher tool', default='matching-instr-counts.csv')
        parser.add_argument('--weight_file_prefix', '-p', help='prefix for output weight files (index follows prefix)', default='weights')
        parser.add_argument('--weight_file_suffix', '-s', help='suffix for output weight files (suffix follows index)', default='.txt')
        args = parser.parse_args()

	# do the job
	labels = readLabels(args.label_file)
        index = 0
        while True:
                traceSlices = readTrace(args.match_file, index)
                if len(traceSlices) == 0: break
                weights = measureWeightsWithLabels(labels, traceSlices)
                writeMeasuredWeight(weights, args.weight_file_prefix + str(index) + args.weight_file_suffix)
                index += 1
        print "Done."

if __name__ == "__main__":
	main(sys.argv[1:])
